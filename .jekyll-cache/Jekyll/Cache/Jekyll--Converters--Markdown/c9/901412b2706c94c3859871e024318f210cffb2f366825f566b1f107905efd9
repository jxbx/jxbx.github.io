I"Ò8<p>I‚Äôve been spending some time working through problem solving challenges on HackerRank; <a href="https://www.hackerrank.com/challenges/append-and-delete/problem?h_r=next-challenge&amp;h_v=zen&amp;h_r=next-challenge&amp;h_v=zen">here‚Äôs one I really enjoyed</a>. It seemed easy to solve at first glance, but it threw up some interesting edge cases, and after a good start it took me a while longer to write a comprehensive function which would handle all the test inputs.</p>

<p>The full problem description is available on the challenge page, but here‚Äôs my summary:</p>

<p>-You start with two strings, <code class="language-plaintext highlighter-rouge">s</code> and <code class="language-plaintext highlighter-rouge">t</code>.</p>

<p>-You can perform two operations on string <code class="language-plaintext highlighter-rouge">s</code>: delete the last character in the string, or add a new character to the end of the string</p>

<p>Given the value <code class="language-plaintext highlighter-rouge">k</code>, is it possible to mutate string <code class="language-plaintext highlighter-rouge">s</code> into string <code class="language-plaintext highlighter-rouge">t</code> in exactly  <code class="language-plaintext highlighter-rouge">k</code> moves, only using these two operations? Return <code class="language-plaintext highlighter-rouge">Yes</code> or <code class="language-plaintext highlighter-rouge">No</code>.</p>

<p>Here‚Äôs an example of how this might work:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s = "superman"
t = "supernoodle"
k = 9

//delete the letters "n", "a" and "m" from the end of string s (3 moves)
//add the letters "n", "o", "o", "d", "l" and "e" to the end of string s (6 moves)

6 + 3 = 9 = k

return "Yes"
</code></pre></div></div>

<p>Great! Notice that because the first five letters of string <code class="language-plaintext highlighter-rouge">s</code> perfectly match the first five letters of string <code class="language-plaintext highlighter-rouge">t</code> we don‚Äôt need to mutate them, which saves us several moves. If we had to delete the whole of string <code class="language-plaintext highlighter-rouge">s</code>, our total number of moves would be <code class="language-plaintext highlighter-rouge">s.length + t.length</code>, or <code class="language-plaintext highlighter-rouge">8 + 11 = 19</code> but instead it is now going to be <code class="language-plaintext highlighter-rouge">s.length - {length of matching part} + t.length - {length of matching part}</code>, or <code class="language-plaintext highlighter-rouge">8 - 3 + 11 - 3 = 9</code>.</p>

<p>A good way to track whether we have any matching leading characters would be to iterate through string <code class="language-plaintext highlighter-rouge">s</code> and record any characters that match. I would do this with:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let match = "";

    for(let i=0; i&lt;s.length; i++){
        if (s[i]===t[i]){
            match += s[i];
        }
        else {
            break;
        }
</code></pre></div></div>

<p>We can now step through string <code class="language-plaintext highlighter-rouge">s</code>, updating the variable <code class="language-plaintext highlighter-rouge">match</code> for as long <code class="language-plaintext highlighter-rouge">s[i]===t[i]</code>. As soon as <code class="language-plaintext highlighter-rouge">s[i]!==t[i]</code> we will break out of the loop, but we will still have our <code class="language-plaintext highlighter-rouge">match</code> variable to hand.</p>

<p>Following our earlier logic, we can now easily calculate the minimum number of moves to mutate <code class="language-plaintext highlighter-rouge">s</code> into <code class="language-plaintext highlighter-rouge">t</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let ans = t.length - match.length + s.length - match.length
</code></pre></div></div>

<p>Or to simplify:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let ans = t.length + s.length - 2*match.length
</code></pre></div></div>

<p>This is excellent, because it works for all cases of <code class="language-plaintext highlighter-rouge">s</code> and <code class="language-plaintext highlighter-rouge">t</code>. Check out the following examples:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s ="bulbous"
t= "bulbasaur"

s= "charizard"
t= "charred"
</code></pre></div></div>

<p>In case 1, where <code class="language-plaintext highlighter-rouge">s.length &lt; t.length</code>, our loop will stop after <code class="language-plaintext highlighter-rouge">s[3]</code> because we‚Äôve declared <code class="language-plaintext highlighter-rouge">i&lt;s.length</code>. This would also work for <code class="language-plaintext highlighter-rouge">s.length === t.length</code>.</p>

<p>In case 2, where <code class="language-plaintext highlighter-rouge">s.length &gt; t.length</code> our loop will stop after <code class="language-plaintext highlighter-rouge">s[3]</code> because <code class="language-plaintext highlighter-rouge">t[4]</code> is <code class="language-plaintext highlighter-rouge">undefined</code> and doesn‚Äôt satisfy <code class="language-plaintext highlighter-rouge">s[i]===t[i]</code>.</p>

<p>The method for breaking out of the loop changes, but the end result is the same. In each case, we know that <code class="language-plaintext highlighter-rouge">match = 4</code>, so we can go ahead and calculate that <code class="language-plaintext highlighter-rouge">ans = 8</code> for each example. For these examples I‚Äôve intentionally chosen words which share leading characters, but this is also fine for words that don‚Äôt, or words that have zero length. In both cases <code class="language-plaintext highlighter-rouge">match.length</code> would be zero, and <code class="language-plaintext highlighter-rouge">ans</code> would simply be <code class="language-plaintext highlighter-rouge">t.length + s.length</code>. The question doesn‚Äôt ask us to solve for words with zero length, but it‚Äôs nice to know we‚Äôve got this covered!</p>

<p>It feels like we‚Äôve nearly solved this! Now we just need to compare <code class="language-plaintext highlighter-rouge">ans</code> against <code class="language-plaintext highlighter-rouge">k</code>, returning <code class="language-plaintext highlighter-rouge">Yes</code> if they are the same, and <code class="language-plaintext highlighter-rouge">No</code> if they are different.</p>

<p>Right? Wrong. The <code class="language-plaintext highlighter-rouge">ans</code> we‚Äôve obtained isn‚Äôt the <em>only</em> answer to this problem, it‚Äôs just the minimum one. In my summary I cheekily glossed over one important piece of information from the question rubric: ‚Äúperforming [the delete function] on an empty string results in an empty string‚Äù. I‚Äôm sure a lot of people answering this question will have noticed this and understood how it affects the solution straight away, but I‚Äôd already done all the previous work before picking up on this, which is why I‚Äôm only mentioning it now.</p>

<p>If we can use up moves by deleting on an empty string, we can take as many moves as we like to mutate string <code class="language-plaintext highlighter-rouge">s</code> into string <code class="language-plaintext highlighter-rouge">t</code>. Here‚Äôs an example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s="abdomen"
t="abracadabra"
</code></pre></div></div>

<p>The minimum score for mutating <code class="language-plaintext highlighter-rouge">s</code> into <code class="language-plaintext highlighter-rouge">t</code> is <code class="language-plaintext highlighter-rouge">s.length+t.length-2*match.length</code>, or <code class="language-plaintext highlighter-rouge">7+11-4 = 14</code>. However, with our new knowledge, we could instead delete all of <code class="language-plaintext highlighter-rouge">s</code>, then use up some arbitrary number of moves deleting on an empty string, then finish by adding all of the letters to make up <code class="language-plaintext highlighter-rouge">t</code>. Our score would now be <code class="language-plaintext highlighter-rouge">s.length+t.length + {some arbitrary number of moves}</code>. This is important, because we can now see that as long as <code class="language-plaintext highlighter-rouge">k &gt;= s.length+t.length</code> we can always come up with a score that will match <code class="language-plaintext highlighter-rouge">k</code>.</p>

<p>We can now update our script. Straight off the bat, before we even bother to look at the content of strings <code class="language-plaintext highlighter-rouge">s</code> and <code class="language-plaintext highlighter-rouge">t</code> we can say:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> if (k&gt;=s.length+t.length){
        return "Yes";
    }
</code></pre></div></div>

<p>So that‚Äôs one major loophole dealt with; surely we‚Äôve now figured this problem out? Well not quite. There‚Äôs a slightly different way for us to manipulate our score without deleting on an empty string, and this one is not explicitly pointed out in the rubric. Here‚Äôs a further example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s="moo"
t="moomin"
</code></pre></div></div>

<p>Clearly our minimum score here is <code class="language-plaintext highlighter-rouge">3</code>. However, we can extend our score by writing and deleting some or all of the string over and over again. The score for something like <code class="language-plaintext highlighter-rouge">moo&gt;moom&gt;moomi&gt;moomin&gt;moomi&gt;moomin</code> would be 5. The score for <code class="language-plaintext highlighter-rouge">moo&gt;mo&gt;m&gt;mo&gt;moo&gt;moom&gt;moomi&gt;moomin</code> would be 7. Like before, we can keep extending this forever to pump our score, but this time there is a restriction. While deleting on an empty string allows us to increase our score in increments of 1, with this new technique whenever we delete a character we must replace it, so we can only increase our score in increments of 2.</p>

<p>In other words, we can generate any score in the form <code class="language-plaintext highlighter-rouge">minAns + n*2</code>, where <code class="language-plaintext highlighter-rouge">minAns</code> is the lowest possible score, and n is the number of paired delete/add moves we want to make to extend our score.  When dealing with odd and even numbers we know that <code class="language-plaintext highlighter-rouge">odd+even === odd</code> and <code class="language-plaintext highlighter-rouge">even+even === even</code>, so if our <code class="language-plaintext highlighter-rouge">minAns</code> is odd any new answer we get from this technique must be odd as well. Likewise, if <code class="language-plaintext highlighter-rouge">minAns</code> is even, any new answer must be <code class="language-plaintext highlighter-rouge">even</code> too. We can now check our score against <code class="language-plaintext highlighter-rouge">k</code> using this test:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (k%2 === 0 &amp;&amp; minAns%2 === 0 || k%2 !==0 &amp;&amp; minAns%2 !== 0){
        return "Yes";
    }
    else {
        return "No";
    }
</code></pre></div></div>

<p>This edge case is quite tricky to spot because it only applies in a very limited set of circumstances. Using the empty string deletion trick we figured out that:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (k&gt;=s.length+t.length){
        return "Yes";
}
</code></pre></div></div>

<p>‚Ä¶so our test above will only be needed if <code class="language-plaintext highlighter-rouge">k&lt;s.length+t.length</code> but larger than our minimum answer. Here‚Äôs a final example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s="jig"
t="jigglypuff"

minAns = 7

//Yes: k&gt;=13, k=9, k=11
//No: k&lt;7
</code></pre></div></div>

<p>The results <code class="language-plaintext highlighter-rouge">No</code> for <code class="language-plaintext highlighter-rouge">k&lt;7</code> and <code class="language-plaintext highlighter-rouge">Yes</code> for <code class="language-plaintext highlighter-rouge">k&gt;=13</code> are easy to figure out, but the extra test is needed to pick out those two loose values (9 and 11) where <code class="language-plaintext highlighter-rouge">minAns &lt; k &lt; s.length+t.length</code>.</p>

<p>With a little bit of tidying, my complete solution for this challenge looks like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function appendAndDelete(s, t, k) {

    if (k&gt;=s.length+t.length){
        return "Yes";
    }
    else{
        let match = "";
        for(let i=0; i&lt;s.length; i++){
            if (s[i]===t[i]){
                match += s[i];
            }
            else {
                break;
            }
        }
        let minAns = t.length + s.length - 2*match.length;
        if (k &lt; minAns){
            return "No";
        }
        else if (k%2 === 0 &amp;&amp; minAns%2 === 0 || k%2 !==0 &amp;&amp; minAns%2 !== 0){
            return "Yes";
        }
        else {
            return "No";
        }
    }
}
</code></pre></div></div>

<p>I‚Äôve come across so many situations while learning to code where I‚Äôve been caught out by pesky edge cases; on this occasion I could have saved some time if I‚Äôd read the question more carefully before writing my solution. An optimal approach could have involved carefully examining every facet of the problem at hand and reasoning out all the edge cases before writing any code at all. However, some edge cases will be hard to fathom out until they present themselves as bugs in the code, and I think there‚Äôs a lot to be said for the pragmatic approach; why not start off with a best guess and then examine, tinker and amend, until all those edges are nicely tidied away?</p>
:ET