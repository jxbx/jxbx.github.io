I"‘D<p>I built the <a href="https://www.justinbailey.net/projects/enigmemulator.html">EnigMemulator</a> a loose clone of the Enigma code machine which was used by the German military to send encrypted messages during World War II. Iâ€™ve been looking for a project to bed in some of the Javascript fundamentals Iâ€™ve learnt, and this has been super fun to work on. The <a href="https://en.wikipedia.org/wiki/Enigma_machine">Wikipedia page</a> on the Engima machine is brilliant, so I recommend reading more there if youâ€™re interested, but Iâ€™ve tried to give a little flavour below of how the original machine worked before jumping into some details of the coding.</p>

<iframe src="/projects/enigmemulator.html" height="600"></iframe>

<p>The machine</p>

<p>The original electro-mechanical Enigma machine looks a little bit like a typewriter. Plaintext messages are entered one character at a time using the keyboard, and a series of modules with complicated internal wiring to link each plaintext character (A,B,C â€¦) to a new ciphertext character. Every time a plaintext character is entered, the equivalent ciphertext character is output on a light-up display for the user to write down as part of their coded message.</p>

<p>Simple alphabetic ciphers which map a message using a scrambled alphabet as the key are very easy to break using simple techniques, like frequency analysis. I know that E,T,A,O,I,N are the most commonly used letters in English, so if I view some coded messages and count which letters occur most often Iâ€™ll be well on the way to breaking the cipher with no special tools at all! To make things worse, repeating the encryption using a whole series of alphabetic substitutions doesnâ€™t make codecracking any harder. As long as we know that every plaintext character maps onto some unique ciphertext character we can skip out all the intermediate stages and look purely at the input and output when we do our frequency analysis.</p>

<p>In order to make full use of these multiple substitutions, we need to add an additional process which mutates the input in a different way. The enigma machine uses a clever  â€œsteppingâ€ function, which updates the cipher every time a new character is entered. Letâ€™s say our plaintext alphabet (a,b,c,d,eâ€¦) maps onto some ciphertext alphabet (p,z,l,k,mâ€¦). In a static cipher, a will always = p and z will always = b (and so on). With a â€œsteppedâ€ cipher, each time I enter a character the cipher â€œstepsâ€ forward by one. After one keystroke, a will now map to z. After another keystroke a will map to b. With a static cipher, the text â€œaaaâ€ will always map to â€œpppâ€. With this stepped cipher, â€œaaaâ€ will instead map to â€œpzlâ€, which is much harder to figure out. The relationships between the input and output characters are now constantly changing, and any character can now be substituted by any other character, depending on when it is entered. Clearly, frequency analysis will not work here! Although our encryption is governed by only a few simple rules, from the outside itâ€™s now extremely difficult to discern what these are: perfect!</p>

<p>The original Enigma machine was set up a bit like a clock, with subsequent modules acting like second, minute and hour hands. The first module would step forward once every keystroke, completing a full rotation after 26 strokes (since the alphabet has 26 characters). The module two (the â€œminute handâ€) would step forward once for every full rotation on module one, and module three (â€œthe hour handâ€) would step forward once for every full rotation of module two.</p>

<p>Step rate:</p>

<p>module 1: 1
module 2: 26
module 3: 26*26 = 676</p>

<p>Thatâ€™s a very basic analysis of the original Enigma. I now needed to replicate this as a Javascript program. A machine with clear inputs and outputs, string manipulation techniques, and iterative processes is already really suited to this kind of adaptation, but I wanted to avoid being constrained by the need to make an exact replica, so my aim was to create something similar, while making changes and alterations if it seemed interesting and/or convenient to do so, without ruining the â€œspiritâ€ of the project.</p>

<p>Building the program</p>

<p>The EnigMemulator uses three levels of alphabetic substitution, and at each level the substitution string can be varied by selecting an initial starting position (startPos) and a stepping rate (stepRate). While the original Enigma machine had a fixed step rate as described above, I decided that my machine should allow this to be set freely. The stepRate can be entered independently for each substitution string.</p>

<p>At each level of the encryption, the substitution string can be set to one of three values:</p>

<p>A: â€œQWERTYUIOPASDFGHJKLZXCVBNMâ€<br />
B: â€œMLPNKOBJIVHUCGYXFTXDRSEAWQâ€<br />
C: â€œBNCMXZLAKSJDHFGYTURIEOWPQVâ€</p>

<p>Adjusting the startPos simply changes the indexing on the string, like so:</p>

<p>subString=â€œQWERTYUIOPASDFGHJKLZXCVBNMâ€</p>

<p>startPos = 0:  â€œQWERâ€¦VBNMâ€<br />
startPos = 1:  â€œWERTâ€¦BNMQâ€<br />
startPos = 2:  â€œERTYâ€¦NMQWâ€<br />
startPos = 3:  â€œRTYUâ€¦.MQWEâ€
â€¦<br />
startPos = 25: â€œMQWEâ€¦CVBNâ€</p>

<p>Because there are 26 characters in the alphabet, a  startPos of 26 simply wraps the string back round to 0. Any number higher than this will simply map to a lower value, so there are only 26 distinct settings available.</p>

<p>Adjusting the stepRate allows us to shift the string every time a character is entered. This is equivalent to counting forward n positions along the string for every new character that is typed.</p>

<p>Input = â€œAAAâ€<br />
subString = â€œQWERTYUIOPASDFGHJKLZXCVBNMâ€<br />
startPos = 0</p>

<p>stepRate = 0 â€¦ Output = â€œQQQâ€<br />
stepRate = 1 â€¦ Output = â€œQWEâ€<br />
stepRate = 2 â€¦ Output = â€œQETâ€</p>

<p>This functionality means that any character can be replaced by any other character, depending on the settings chosen and the length of the string. In the example above, repeatedly entering the same character results in a different output each time. Conversely, setting the stepRate to 25 and entering a string of successive characters like â€œABCâ€ will result in a bizarre looking (but correct!) output of â€œQQQâ€, where the same character is returned each time.</p>

<p>Like before, any value of 26 or above simply wraps the string round to one of the initial 26 positions, setting a limit on how many distinct settings we can choose.</p>

<p>Writing the encryption function</p>

<p>The route our plaintext input takes through the code machine looks something like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            startPos1 	  startPos2      startPos3
               |              |		           |
Input  &gt;  subString1  &gt;  subString2  &gt;  subString3  &gt;  output
               |              |              |
           stepRate1 	    stepRate2      stepRate3
</code></pre></div></div>

<p>The encryption has three stages, and at each stage we need to set <code class="language-plaintext highlighter-rouge">startPos</code>, <code class="language-plaintext highlighter-rouge">subString</code> and <code class="language-plaintext highlighter-rouge">stepRate</code>, making nine variables in total. These variables are all stored in a nested array for easy access.</p>

<p>The <code class="language-plaintext highlighter-rouge">startPos</code> and <code class="language-plaintext highlighter-rouge">stepRate</code> variables are a bit of a distraction at this stage, so letâ€™s focus initially on just taking our plaintext input and running it through the <code class="language-plaintext highlighter-rouge">subString</code> variables.</p>

<p>We type our plaintext message into a text input box, and this gets passed into the <code class="language-plaintext highlighter-rouge">showCiphertext()</code> function, forced to lowercase and assigned as the variable <code class="language-plaintext highlighter-rouge">string</code> . Starting with the first character of our input string we generate a <code class="language-plaintext highlighter-rouge">charIndex</code> using <code class="language-plaintext highlighter-rouge">charCodeAt()</code>. This assigns a numerical value based on the characterâ€™s ASCII code. The ASCII codes for the lowercase letters a-z range from 97-122, so to make life easier we subtract 97, meaning <code class="language-plaintext highlighter-rouge">charIndex</code> values  for a, b, c â€¦ z will be 0, 1, 2 â€¦ 25 respectively. Uppercase letters have their own codes, which is why we needed to force lowercase in advance; a couple of additional lines of code are also needed to stop any non-alphabetic characters from being handled and to preserve the space character.</p>

<p>Next up, we use the <code class="language-plaintext highlighter-rouge">charIndex</code> to assign <code class="language-plaintext highlighter-rouge">charNew</code> as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let charIndex = string.charCodeAt(n) - 97;
...
charNew = subString.charAt(charIndex);
</code></pre></div></div>

<p>To show how this might work across multiple substitution strings, have a look at the illustration below, which uses the input string â€œarmadilloâ€:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>â€œarmadilloâ€
|
a (string[0] = â€œaâ€, charIndex = 0)
|
qwertyuiopasdfghjklzxcvbnm (charNew = subString.charAt(0) = â€œqâ€)
|_______________
                |
abcdefghijklmnopqrstuvwxyz (string = â€œqâ€, charIndex = 16)
                |
qwertyuiopasdfghjklzxcvbnm (charNew = subString.charAt(16) = â€œjâ€)
          ______|
         |
abcdefghijklmnopqrstuvwxyz (string = â€œjâ€, charIndex = 9)
         |
qwertyuiopasdfghjklzxcvbnm (charNew = subString.charAt(9) = â€œpâ€)
         |
         Output = â€œpâ€
</code></pre></div></div>

<p>Wow! Now how about adding <code class="language-plaintext highlighter-rouge">stepRate</code> and <code class="language-plaintext highlighter-rouge">startPos</code> into the mix? As mentioned before, these two values will take a <code class="language-plaintext highlighter-rouge">subString</code> and nudge the starting point to a different position along the string. <code class="language-plaintext highlighter-rouge">startPos</code> will do this once, at the start of the string, and  <code class="language-plaintext highlighter-rouge">stepRate</code> will do this for each time we encounter a new character in the string. If we use indexing we can convert everything into numbers and make this really simple.</p>

<p>We started along this path by assigning <code class="language-plaintext highlighter-rouge">charIndex</code> .  A new <code class="language-plaintext highlighter-rouge">encodeChar()</code> function takes this value and manipulates it based on the <code class="language-plaintext highlighter-rouge">startPos</code> and <code class="language-plaintext highlighter-rouge">stepRate</code> values weâ€™ve selected.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function encodeChar(input, startPos, stepRate, num) {
  return (input + startPos + stepRate * num)%26;
}
</code></pre></div></div>

<p>Letâ€™s try this on our test phrase, â€œarmadilloâ€:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>â€œarmadilloâ€
|
a (string[0] = â€œaâ€, charIndex = 0)

encodeChar (0, 15, 9, 0);

//expected result: 15


â€œarmadilloâ€
|
r (string[1] = â€œrâ€, charIndex = 17)

encodeChar (17, 15, 9, 1);

//expected result: 13

â€¦
</code></pre></div></div>

<p>Notice that while the <code class="language-plaintext highlighter-rouge">startPos</code> value stays the same,  the <code class="language-plaintext highlighter-rouge">stepRate</code> value gets multiplied out as we progress along the string. <code class="language-plaintext highlighter-rouge">startPos</code> only defines our starting position. <code class="language-plaintext highlighter-rouge">stepRate</code> moves us forward by a set amount every time we enter a new character.</p>

<p>Whatever numerical result we get, we need to ensure it maps to a value in the range 0-26, so it can be assigned to one of the 26 characters in the alphabet, so we need to use modulus to get a remainder on any values that are too large.</p>

<p>The <code class="language-plaintext highlighter-rouge">encodeChar</code> function sits inside <code class="language-plaintext highlighter-rouge">showCiphertext</code> and handles the numbers, while <code class="language-plaintext highlighter-rouge">showCiphertext</code> deals with converting strings into numerical form and back, assigning the ciphertext output to the  variable <code class="language-plaintext highlighter-rouge">newString</code>. Next, we assign <code class="language-plaintext highlighter-rouge">newString</code> to <code class="language-plaintext highlighter-rouge">string</code> and start the whole process from the top. Remember the nested array where we are storing all our parameters for the encryption? It looks like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const subsArray =
      [[substring1Element, startPos1Element, stepRate1Element],                
       [substring2Element, startPos2Element, stepRate2Element],           
       [substring3Element, startPos3Element, stepRate3Element]];
</code></pre></div></div>

<p>Once we have our encryption function, we can iterate through each set of variables using a for loop:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (let i = 0; i&lt;subsArray.length; i++){

  let subString = subsArray[i][0].value;
  let startPos = parseInt(subsArray[i][1].value);
  let stepRate = parseInt(subsArray[i][2].value);
</code></pre></div></div>

<p>Hereâ€™s an example of how the input string flows through the function using <code class="language-plaintext highlighter-rouge">subsArray = [[A,0,0],[A,0,0],[A,0,0]]</code> :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>string = â€œhelloâ€    ... subsArray[0]           
    |		 
newString = â€œitssgâ€	... subsArray[1]  
    |		
newString = â€œozlluâ€	... subsArray[2]
    |		
newString = â€œgmssxâ€
</code></pre></div></div>

<p>What about decoding?</p>

<p>Adding a decode function made sense, both as a useful feature, and as a way of verifying that the program was actually generating real ciphertext instead of a nonsensical string! This was pretty simple: <code class="language-plaintext highlighter-rouge">showPlaintext</code> is a mirror image of <code class="language-plaintext highlighter-rouge">showCiphertext</code>, performing the same processes in reverse, and iterating backwards through the <code class="language-plaintext highlighter-rouge">subsArray</code>. Likewise, <code class="language-plaintext highlighter-rouge">decodeChar</code> is a mirror version of <code class="language-plaintext highlighter-rouge">encodeChar</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function decodeChar(input, startPos, stepRate, num){
  return (input + (26 - startPos) + (26 - stepRate) * num)%26
}
</code></pre></div></div>

<p>Rather than having two separate user interfaces for encoding or decoding a message, it made sense to simply include a toggle to select one or other process. By default the program is set to â€œencodeâ€: the user types their plaintext into the text input box, sets the parameters, and watches their ciphertext appear in the output box at the bottom of the interface. Selecting â€œdecodeâ€ puts the machine in reverse mode, and the user can now type in ciphertext, using the parameter controls to look in the correct pattern to decrypt the message. To accomplish this, the <code class="language-plaintext highlighter-rouge">showCiphertext</code> and <code class="language-plaintext highlighter-rouge">showPlaintext	</code> functions are wrapped in a <code class="language-plaintext highlighter-rouge">runEnigmemulator()</code> function which uses a conditional to check the user input before running one or other of the functions.</p>

<p>The key</p>

<p>As a final feature, the function <code class="language-plaintext highlighter-rouge">generateKey()</code> allows the user to generate a keystring which they can use to record the encryption parameters on their message. <code class="language-plaintext highlighter-rouge">generateKey()</code> checks the values in the <code class="language-plaintext highlighter-rouge">subsArray</code> and returns a key in the form â€œX-XX-XX-X-XX-XX-X-XX-XXâ€, listing the nine parameter settings and separating them with dashes.</p>

<p>Finally</p>

<p>This was a really challenging and fun project, and although the EnigMemulator is slightly different from the original Enigma, I still think itâ€™s a pretty nice interpretation. The original machine became more complex over time and had some additional features added to increase the complexity of its encryption - it was a shame not to include these, but donâ€™t worry, because EnigMemulator 2.0 will come around soon!</p>
:ET