I"¿1<p>Recursive functions can be a bit mindbending when you first encounter them. As part of my process to understand them better I looked at some simple examples and tried to step through each function stage by stage to get an idea of how the seemingly paradoxical process of a function calling itself can actually return a result. My intial way into this was through the ‚Äúbubbling up‚Äù analogy, which really intuitive and easy to grasp. Once that makes sense, there‚Äôs a refinement to the analogy which looks at the way the call stack manages function calls when a script is being run in browser.</p>

<p>Check out this example of a really simple recursive function:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function factorial(n){
  if (n === 1){
  return 1;
  {
  else {
  return n * factorial (n-1);
  }
}
</code></pre></div></div>

<p>The function <code class="language-plaintext highlighter-rouge">factorial(n)</code> simply calculates n!, <a href="https://en.wikipedia.org/wiki/Factorial">factorial</a> of the integer <code class="language-plaintext highlighter-rouge">n</code>, which can be found by evaluating <code class="language-plaintext highlighter-rouge">n * (n-1) * (n-2) * (n-3) ... * 1</code>. There are ways to evaluate the factorials of 0 and of minus numbers, but for simplicity this function will only work as long as <code class="language-plaintext highlighter-rouge">n&gt;=1</code>.</p>

<p>Clearly theres a lot of repetition required to evaluate a factorial, and that‚Äôs why it makes sense to write it as a recursive function. Just like all recursive functions this one includes a recursive condition (the condition under which it will call itself again, creating a loop) and a break condition (the condition where the function eventually terminates, breaking out of the loop). Here, the break condition is met when <code class="language-plaintext highlighter-rouge">n === 1</code> since there are no more integers left to multiply after this.</p>

<p>Plugging in a value and stepping through the function in your head might go something like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>console.log(factorial(5))
‚Üì
//5 != 0 so ignore the break condition
‚Üì
return 5 * factorial(4)
‚Üì
// cannot evaluate!
</code></pre></div></div>

<p>At this point the universe should crack open because surely there‚Äôs no way to evaluate a function whose value is another function call! The solution is to keep going deeper: if <code class="language-plaintext highlighter-rouge">factorial(5)</code> can only be evaluated when we know the value of <code class="language-plaintext highlighter-rouge">factorial(4)</code> then we need to evaluate that too. If factorial(4) can only be evaluated when we know the value of <code class="language-plaintext highlighter-rouge">factorial(3)</code> ‚Ä¶ well you get it. We need to keep descending further and further until we hit something we can actually know the value of ‚Ä¶ which is where the break condition comes in.</p>

<p>When we hit <code class="language-plaintext highlighter-rouge">factorial(1)</code> we break out of the loop and finally return the value of 1. Now we can start the long climb back up to the top of this tree of nested function calls. Using our value for <code class="language-plaintext highlighter-rouge">factorial(1)</code> we can evaluate <code class="language-plaintext highlighter-rouge">factorial(2)</code> (2 * 1 = 2). This lets us evaluate <code class="language-plaintext highlighter-rouge">factorial(3)</code> (3 * 2 * 1 = 6). This then gives <code class="language-plaintext highlighter-rouge">factorial(4)</code>, which then gives <code class="language-plaintext highlighter-rouge">factorial(5)</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>factorial(5) = 5*---------------120  // finally!
  ‚Üì                           	‚Üë
  factorial(4) = 4*-------------24
    ‚Üì                       	‚Üë
    factorial(3) = 3*-----------6
      ‚Üì                     	‚Üë
      factorial(2) = 2*---------2
	‚Üì                 	‚Üë
	factorial(1) = -----‚Üí---1
</code></pre></div></div>

<p>The analogy of ‚Äúbubbling up‚Äù which I first came across in <a href="https://www.youtube.com/watch?v=LteNqj4DFD8">This video</a> was a huge help in understanding how this kind of function works. When we have a whole tree of nested function calls waiting to be resolved, the bottom of the tree is where the chain of evaluations starts. As we successfully evaluate and close function calls, the result ‚Äúbubbles‚Äù up to the top of the tree, eventually returning a result for our original function call.</p>

<p>This seems neat and tidy, but what happens when we move onto more complex recursive functions? Have a look at the <code class="language-plaintext highlighter-rouge">range()</code> function below:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function range(a,b){
  if (b-a === 1){
    return [];
  }
  else {
    let list = range(a,b-1);
    list.push(b-1);
     return list;
  }
}
</code></pre></div></div>

<p>This function returns the list of integers that fall between the values <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>, where <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> are both integers, and <code class="language-plaintext highlighter-rouge">a &lt; b</code>. The expected result for <code class="language-plaintext highlighter-rouge">range(2,9)</code> would be <code class="language-plaintext highlighter-rouge">[3,4,5,6,7,8]</code>.</p>

<p>The break condition for this function is <code class="language-plaintext highlighter-rouge">b-a === 1</code> , since at this point there are no integers left between <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> so there‚Äôs nothing else for us to log as part of our result. Later, we‚Äôll see why it‚Äôs essential here that we return an empty array rather than ‚Äú0‚Äù or an empty string.</p>

<p>The recursive part of the function has three steps:</p>

<ol>
  <li>Generate the variable <code class="language-plaintext highlighter-rouge">list</code></li>
  <li>push a value onto <code class="language-plaintext highlighter-rouge">list</code></li>
  <li>return <code class="language-plaintext highlighter-rouge">list</code></li>
</ol>

<p>The tricky part here is in step 1: <code class="language-plaintext highlighter-rouge">list</code> needs to be assigned as <code class="language-plaintext highlighter-rouge">range(a,b-1)</code>, which we haven‚Äôt yet evaluated. Like before, we are going to have to build a tree of nested functions, going deeper until we hit something we can evaluate; only at this point can we complete the original <code class="language-plaintext highlighter-rouge">let list...</code> instruction and assign the variable <code class="language-plaintext highlighter-rouge">list</code>.
Using <code class="language-plaintext highlighter-rouge">range(2,6)</code> as an example we would expect to get a tree like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>range (2,6) ‚Üí let list= -----[3,4,5]  &lt;&lt;list.push(b-1)
  ‚Üì                           ‚Üë
  range (2,5)----------------[3,4]  &lt;&lt;list.push(b-1)
    ‚Üì                         ‚Üë
    range (2,4)--------------[3]  &lt;&lt;list.push(b-1)
      ‚Üì 		      ‚Üë
      range (2,3)------‚Üí-----[]  &lt;&lt;list gets assigned here!
</code></pre></div></div>

<p>Again, although we attempt to create <code class="language-plaintext highlighter-rouge">list</code> right at the top of the tree, we only complete that assignment right at the bottom. Only now can we move onto step 2, and start pushing values into <code class="language-plaintext highlighter-rouge">list</code>. Now it‚Äôs clear why we needed to return an empty array as part of the break condition: there wouldn‚Äôt be an array to push variables into if we didn‚Äôt define it here. Now we have our array, we can carry out step 2 for each of our nested function calls. Once this is done, we can finally move onto step 3, and return our completed <code class="language-plaintext highlighter-rouge">list</code>.</p>

<p>This order of progress is not entirely intuitive, so adding a couple of <code class="language-plaintext highlighter-rouge">console.log</code>s into the function body can help to clarify things:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function range(a,b){
  if (b-a === 1){
    console.log("two");
    return [];
  }
  else {
    console.log("one");
    let list = range(a,b-1);
    console.log("three");
    list.push(b-1);
     return list;
  }
}
console.log(range(2,6));


//expected result

"one"
"one"
"one"
"two"
"three"
"three"
"three"
[3,4,5]
</code></pre></div></div>

<p>The ‚Äúbubbling up‚Äù analogy from earlier really makes sense in this function. Intuitively we might expect the result <code class="language-plaintext highlighter-rouge">[5,4,3]</code> when we call <code class="language-plaintext highlighter-rouge">range(2,6)</code> since <code class="language-plaintext highlighter-rouge">b = 6</code> is the first parameter we attempt to evaluate. Looking at the entire function tree we can see that we only start to push values into the array right at the bottom of the tree, filling the array in reverse order, from bottom to top.</p>

<p>‚ÄúBubbling up‚Äù is a really useful way to conceptualise recursive functions, but there‚Äôs an alternative way to look think about this with reference to the data structures at work under the hood while our function is running. When I run a script in my browser, it uses a <a href="https://developer.mozilla.org/en-US/docs/Glossary/Call_stack">call stack</a> to keep track of which functions need to be called, and manage which function is being run at any particular time. The stack is a bit like a pile of dishes - items are constantly being taken off the top of the stack to tidy them away, and at the same time new items are added back on to the top. If a script is run with multiple function calls inside it, each of these will be evaluated and tidied away as necessary before progressing through the script. If a function call cannot be evaluated immediately, it stays on the bottom of the stack until we have the information we need to get a result. Have a look at this script:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function total(){
  console.log(first()+second());
}
function first(){
  return 5;
}
function second(){
  return 6;
}
total();
</code></pre></div></div>

<p>First we call <code class="language-plaintext highlighter-rouge">total()</code>, but this cannot be evaluated until we‚Äôve called <code class="language-plaintext highlighter-rouge">first()</code> and <code class="language-plaintext highlighter-rouge">second()</code>. So <code class="language-plaintext highlighter-rouge">total()</code> goes onto the bottom of the stack, while <code class="language-plaintext highlighter-rouge">first()</code> and <code class="language-plaintext highlighter-rouge">second()</code> are added above it. When <code class="language-plaintext highlighter-rouge">first()</code> and <code class="language-plaintext highlighter-rouge">second()</code> are evaluated we can clear them off the stack and pass their values into <code class="language-plaintext highlighter-rouge">evaluate</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>				+---------+	+---------+
				|second() |	| = 6     |
		+---------+	+---------+	+---------+
		| first() |	|first()  |	| = 5     |
+---------+	+---------+     +---------+	+---------+	+---------+
| total() | ‚Üí   | total() | ‚Üí   | total() | ‚Üí	| total() | ‚Üí   | = 11    |
+---------+     +---------+     +---------+	+---------+ 	+---------+
</code></pre></div></div>

<p>How does this work for a recursive function? There‚Äôs no difference really. Here‚Äôs an animation to demonstrate how the call stack manages the <code class="language-plaintext highlighter-rouge">factorial()</code> function from above:</p>

<p><img src="https://github.com/jxbx/jxbx.github.io/blob/main/images/factorialanim.gif?raw=true" width="400px" class="blog-img" /></p>
:ET