I"Ì<p>My friend Lucie pointed out earlier this week that 2021 is a rare year whose value is the product of two consecutive primes. Apparently this hasn‚Äôt happened since 1763 and won‚Äôt happen again until 2491. Clearly this has great cosmological significance, so I decided to check the figures in case of any awkward mistakes.</p>

<p>In the code below the function <code class="language-plaintext highlighter-rouge">checkPrime(n)</code> generates an array of prime numbers up to some maximum value. The <code class="language-plaintext highlighter-rouge">primeMultiples()</code> function works through this array and logging every possible value for n * (n+1).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let primes = [];

function findPrimes(n) {
  for (let i = 2; i &lt;= n; i++) {
    let isPrime = true;
    for (let j = 2; j &lt; i; j++) {
      if (i % j === 0) {
        isPrime = false;
        continue;
      }
    }
    if (isPrime) {
      primes.push(i);
    }
  }
  console.log(primes);
}

findPrimes(100);

function primeMultiples() {
 for (let n = 0; n &lt; primes.length - 1; n++) {
    console.log(primes[n] * primes[n + 1]);
  }
}

primeMultiples();
</code></pre></div></div>

<p>Comparing against this output we can see that Lucie‚Äôs initial dates were correct! Not a hugely difficult problem to solve, but it got me thinking about methods for generating primes. In my function I used trial division, a pretty naive approach where every number in the list of numbers [2,3,4,‚Ä¶n] is checked against every number below it to see if it will factorise. For each number, a variable <code class="language-plaintext highlighter-rouge">isPrime</code> is generated; this starts off <code class="language-plaintext highlighter-rouge">true</code>, and flips to <code class="language-plaintext highlighter-rouge">false</code> if a factor is discovered. If a number survives every check against possible factors, it stays <code class="language-plaintext highlighter-rouge">true</code> and gets logged to the console.</p>

<p>This method is rigourous but slow, so I had a go at making an alternative prime generator based on the ‚Äúsieve of Eratosthenes‚Äù algorithm, which takes a more efficient approach.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function sievePrimes(n){

let startArray = [];
let limit = Math.sqrt(n)
let primes = [];

for (let i = 0; i &lt; n; i++) {
    array.push(true);
  }
  for (let i = 2; i &lt;= limit; i++) {
        if (array[i]) {
            for (let j = i * i; j &lt; n; j += i) {
                array[j] = false;
            }
        }
    }
 for (let i = 2; i &lt; n; i++) {
       if(array[i]) {
           primes.push(i);
        }
    }
    return primes;


}

console.log(sievePrimes(100));
</code></pre></div></div>

<p>Like before, <code class="language-plaintext highlighter-rouge">sievePrimes()</code> initially treats all numbers as potential primes: we start off with an empty array and generate a <code class="language-plaintext highlighter-rouge">true</code> value for every number in our list [2,3,4,‚Ä¶n]. Starting with our lowest value (2), we generate every possible multiple of (4,6,8‚Ä¶) and mark it <code class="language-plaintext highlighter-rouge">false</code> since we know 2 is a factor. We do the same with each subsequent number all the way up to n, quickly whittling down the field of possible prime candidates. The wikipedia page on this alogorithm has a great animation to illustrate how this works.</p>

<p>As an additional timesaver, the inner loop of this function starts with the square of each value; since we‚Äôre evaluating every possible multiple of each value, we know that by the time we get to 5 (for example), that 5+5=10 will already have been evaluated as 2+2+2+2+2 and 5+5+5=15 will have been evaluated as 3+3+3 and earmarked as non-prime at an earlier iteration of the function: there‚Äôs no reason to start our checks before we get to 5*5=25.</p>

<p>A similar logic allows us to use <code class="language-plaintext highlighter-rouge">limit = Math.sqrt(n)</code> to terminate the inner loop. Clearly <code class="language-plaintext highlighter-rouge">sqrt(n)*sqrt(n)</code> is the biggest possible pair of factors we will find for a number in our range, so there‚Äôs no need to run checks using any value larger than this.</p>

<p>Working on these functions has highlighted a couple of things I‚Äôve already discovered while learning coding. Most problems have multiple solutions, and figuring out how to slice the cake in many ways can be really useful for learning and development. However, the simple solution can sometimes be just as valuable as the optimised solution in terms of effort versus results and time saved.</p>
:ET