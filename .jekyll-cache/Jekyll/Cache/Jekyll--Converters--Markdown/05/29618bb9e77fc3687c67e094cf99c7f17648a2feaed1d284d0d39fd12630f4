I"Fw<p>xxBreakBuilder is a simple web application which works as a score tracker in the game of snooker. The BBC sometimes show an <a href="https://www.reddit.com/r/snooker/comments/65oel7/can_anyone_explain_the_point_of_this_infographic/">interesting score graphic</a> alongside their snooker coverage on TV; the purpose of this is to show how many points a player has scored, the maximum number of points they could score, and the minimum number of points they need to win. This is all useful information, but I’ve always found the score bar hard to interpret because it only ever appears as a static graphic at random points during a game. In snooker, a player can choose from multiple scoring options while they are playing the game, and every choice they make has an effect on the overall game state, so to reflect this I’ve tried to make a dynamic score bar where it’s possible to see the graphic update in real time as a player accumulates points.</p>

<p>Due to the fiddly nature of snooker’s scoring system, it’s necessary to keep track of several variables in order to correctly record the game state compute the score as the game progresses, which means that as well as having some real world relevance this this has been an interesting coding challenge with lots of opportunities to think about and learn about state management. You can have a look at my minimum viable product below, built using vanilla Javascript. In the rest of the blog post you can read about the development. I start with a bit of contextual background before jumping into the code.</p>

<iframe src="/projects/breakbuilder.html" width="100%" height="700" style="border: none;">
</iframe>

<p><em>Background</em></p>

<p>Snooker is a cue sport, like pool, which you play by shooting balls into pockets in the corners and sides of a special table. Snooker is played on a much larger table than pool and is an unbelievably difficult game in real life. It’s also insanely popular; in the UK, prime time TV schedules are wiped to broadcast it, and millions of people watch.</p>

<p>Snooker is a two player game played in segments called “frames” (basically the same as “racks” in pool). the winner at the end of each frame is the person who scores the most points, and the overall winner is the first person to accumulate some agreed number of frames. In casual play this might be first to five, but in elite play an outright victory can require you to win up to 18 frames.</p>

<p>Snooker has a unique scoring system, which I’ve often had to explain to non-enthusiasts; usually this starts with me saying “it really isn’t that complicated…” and ends with them leaving the room. Well, here goes:</p>

<ol>
  <li>
    <p>There are seven different colours of ball, each worth a different number of points.</p>

    <p>Red (1); Yellow (2); Green (3); Brown (4); Blue (5); Pink (6); Black (7)</p>
  </li>
  <li>
    <p>There are fifteen red balls but only one each of the other colours. These other colours are usually referred to collectively as the “colour balls” (as opposed to the “red balls”).</p>
  </li>
  <li>
    <p>To score a run of points (a “break”) you must start by potting (scoring) a red ball. You must then pot a colour ball, and continue by alternating red-colour-red-colour for as long as you can.</p>
  </li>
  <li>
    <p>When you pot a red ball it is removed from the table for good. When you pot a colour ball it is brought back onto the table so it can be potted again.</p>
  </li>
  <li>
    <p>Eventually, all fifteen red balls will be potted and only the colour balls will remain on the table. At this point, you must pot the colour balls in order of points value, working your way up from yellow to black.</p>
  </li>
</ol>

<p>If you succeed in doing all this, you will have made what is known as a “clearance”. This happens pretty often on TV, but it’s actually really difficult, and most amateur players can’t do it. If you miss at any point, the other player comes to the table and starts the sequence again, beginning with a red (or whichever colour has the lowest value if all the reds are gone), hoping to accumulate enough points to overtake you. There are ways to score points from fouls, and technically the frame isn’t over until all the balls are potted, but players will usually concede rather than coming to the table if their opponent misses but it’s mathematically impossible for them to catch up by potting all the remaining balls.</p>

<p>With this in mind it’s pretty easy to calculate the maximum number of points a single player could score in a frame.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(red.value + black.value)*red.quantity + (total value of the six colour balls)
</code></pre></div></div>

<p>Fill in the figures and we get the magic total for the perfect game:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(1+7)*15 + 7! = 147
</code></pre></div></div>

<p>So how do we keep track of the score here? And how do we go about creating something that looks a bit like the BBC’s score bar?</p>

<p><em>Problem analysis</em></p>

<p>I imagine my score bar looking something like this:</p>

<p><img class="blog-img" src="/blog/assets/02.jpg" /></p>

<p>The full width of the score bar represents the theoretical maximum points available in the game, which we now know is 147. This value never changes.</p>

<p>Within this, we have the score (how many points you’ve made so far) and the remaining points (the maximum points still available). Both of these values will change as the game goes on. Add them together and you get the total points in the game <em>at that stage of the game</em>. If you only ever potted red and black balls this total would remain equal to 147. However, every time you have the chance to pot a black ball and choose a lower value colour ball this value goes down, since you are essentially losing points from the game. Our final element is the marker which shows us how many more points we need to secure victory; although this might seem like it’s just a fixed value, it’s actually a variable as well, as I’ll explain later.</p>

<p>We also need some inputs, and an output which can be used to show alert messages:</p>

<p><img class="blog-img" src="/blog/assets/01.jpg" /></p>

<p>In order to make this work, there are a few different variables we need to think about:</p>

<ol>
  <li>
    <p><em>What colour next?</em> Are we shooting at a red, or a colour? If it’s a colour, which one?</p>
  </li>
  <li>
    <p><em>What phase of the game are we in?</em> There are two distinct phases of the game. Phase 1, the “red/colour” phase, is where we alternate potting between red and colour balls and colour balls are continually replaced. Phase 2, the “clear the colours” phase, is where all the reds have been potted and we just need to pot the colours in order. The scoring sequence and the behaviour of the balls changes depending on the phase, so we need to know when to make this switch.</p>
  </li>
  <li>
    <p><em>What’s the score?</em> How many points have we accumulated so far?</p>
  </li>
  <li>
    <p><em>What’s the total number of points in the game?</em> To get the maximum possible score you must pot a black ball with every red ball. Potting a different colour increases your score but reduces the total number of points in the game. Potting a red and then missing also reduces the number of points in the game, because your opponent must score a red as their first ball, meaning the colour ball is missed out.</p>
  </li>
  <li>
    <p><em>Where’s the winning line?</em> At what point are we mathematically certain of winning (barring points from fouls), and how many points do we need to get there? My simple interpretation is that in order to get an insurmountable lead we need just over half all the available points. If there were 99 points available, I’d need 50, leaving only 49 for my opponent. If there were 100 points available I’d need 51. A really important thing to note is that although the winning line is calculated from the total number of points in the game, it’s actually a variable. At the start of the game I will need 74 points to win, assuming I just pot reds and blacks. As the game progresses, every time I remove points from the game by choosing to pot any colour other than black, I’m slightly lowering the winning threshold. If I just potted reds and yellows I could eventually win with only 42 points! However, I’m also reducing the speed at which I accumulate points. I’d only have to pot 20 balls to win with reds and blacks, but I’d need to pot 28 balls to win using reds and yellows!</p>
  </li>
</ol>

<p><em>Method</em></p>

<p>TO start, I declared the array <code class="language-plaintext highlighter-rouge">balls</code>, with an object entry for each colour. The two important values to keep track of here are <code class="language-plaintext highlighter-rouge">quantity</code> and <code class="language-plaintext highlighter-rouge">points</code> (i.e. the points value of each colour).</p>

<p>let balls = [
   {colour: “red”, quantity: 15, points: 1},
   {colour: “yellow”, quantity: 1, points: 2},
   {colour: “green”, quantity: 1, points: 3},
   {colour: “brown”, quantity: 1, points: 4},
   {colour: “blue”, quantity: 1, points: 5},
   {colour: “pink”, quantity: 1, points: 6},
   {colour: “black”, quantity: 1, points: 7}
  ];</p>

<p>For convenience, I then created a lookup table which allows me to access the relevant object in <code class="language-plaintext highlighter-rouge">balls</code> using a string (“red”, “yellow” etc) rather than its index. To calculate the score I’m planning to write functions which can be called against any colour, and to make the code more readable I want to be able to do this by passing plain English arguments into the function so I can call <code class="language-plaintext highlighter-rouge">myFunction("red")</code> or <code class="language-plaintext highlighter-rouge">myFunction("yellow")</code> rather than <code class="language-plaintext highlighter-rouge">myFunction(0)</code> or <code class="language-plaintext highlighter-rouge">myFunction(1)</code>.</p>

<p>const lookup = {
    “red”: 0,
    “yellow”: 1,
    “green”: 2,
    “brown”: 3,
    “blue”: 4,
    “pink”: 5,
    “black”: 6
  };</p>

<p>I can now manage the state of the balls, but I still need declare some global variables to manage the state of the scoring:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let score = 0; // total points from balls potted

let remaining = 0; // max points available from remaining balls

let redOn = true; // red available for next shot?

let tableCleared = false; // ready to clear the colours?

const maxPoints = updateRemaining(); // max possible points available - declared at initialisation
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">score</code> and <code class="language-plaintext highlighter-rouge">remaining</code> variables keep track of how many points we’ve achieved, and how many points are left. These will be used to generate the values in the score bar.</p>

<p><code class="language-plaintext highlighter-rouge">score</code> is of course set to <code class="language-plaintext highlighter-rouge">0</code> on initialisation. We know already that in standard snooker <code class="language-plaintext highlighter-rouge">remaining</code> should be set to <code class="language-plaintext highlighter-rouge">147</code> at the beginning of the frame, but instead of hardcoding this value I’ve also set it to <code class="language-plaintext highlighter-rouge">0</code> to start with. When the page loads I’ll call a function <code class="language-plaintext highlighter-rouge">updateRemaining()</code> which will calculate <code class="language-plaintext highlighter-rouge">remaining</code> based on the values in <code class="language-plaintext highlighter-rouge">balls</code>. This seems more rigorous, and it means that if we decided to change the values in <code class="language-plaintext highlighter-rouge">balls</code> for any reason the calculator would still work. Whenever we update the score we’ll change the values in <code class="language-plaintext highlighter-rouge">balls</code> and call <code class="language-plaintext highlighter-rouge">updateRemaining()</code> again to update the <code class="language-plaintext highlighter-rouge">remaining</code> variable.</p>

<p>The booleans <code class="language-plaintext highlighter-rouge">redOn</code> and <code class="language-plaintext highlighter-rouge">tableCleared</code> are important for checking the game state. <code class="language-plaintext highlighter-rouge">redOn</code> toggles based on whether the last ball we potted was a red, so we always know what colour we are shooting at next. <code class="language-plaintext highlighter-rouge">tableCleared</code> monitors what phase the game is in. Remember, once all the red/colour pairs have been potted the scoring sequence and the behaviour of the remaining balls changes.</p>

<p>It’s really important to note here that the second phase of the game only starts after the last red <em>and</em> its subsequent colour are potted, and not just when there are no reds left. When we pot the final red, we then pot a colour, which is returned to the table. Only then do we move to phase 2. It would be easy for an error situation to occur here simply by toggling <code class="language-plaintext highlighter-rouge">tableCleared</code> at the wrong time. The correct sequence should be:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>... red &gt; colour &gt; `tableCleared === true` &gt; colour &gt; colour ...
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">maxPoints</code> const represents the “perfect” score; the theoretical maximum points available if you always pot the highest scoring balls. This will eventually determine the overall width of the score bar. We’ll define the widths of <code class="language-plaintext highlighter-rouge">score</code> and <code class="language-plaintext highlighter-rouge">remaining</code> relative to <code class="language-plaintext highlighter-rouge">maxPoints</code>. We know that <code class="language-plaintext highlighter-rouge">remaining === maxPoints === 147</code> at the start of the frame, so we can use <code class="language-plaintext highlighter-rouge">updateRemaining()</code>  to set the value of <code class="language-plaintext highlighter-rouge">maxPoints</code> on initialisation, making sure to declare it as a const so the value is locked in and won’t be recalculated when the game state changes.</p>

<p>These elements should be everything we need to manage the state of our game. I now need to write some functions which I can use to change the game state. I’ll start by looking at the potting actions:</p>

<p>Case 1: trying to pot a red ball
Case 2: trying to pot a colour ball during the “red/colour” phase
Case 3: trying to pot a colour ball during the “clear the colours” phase</p>

<p>Case 1:</p>

<p>When we try to pot a red ball, we need to check whether <code class="language-plaintext highlighter-rouge">redOn === true</code>. This will confirm whether we can shoot at a red on our next go. We then need to check that <code class="language-plaintext highlighter-rouge">balls[0].quantity &gt; 0</code> to confirm there are still reds available. If we fail either of these tests an alert message will be returned. If we pass both tests we can now proceed to update the state of the game:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function potRed() {

//if a red has just been potted:

    if (!redOn){
      alertText.innerText = "choose a colour ball";
      return;
    }

// if there are no reds left:

    if (balls[0].quantity &lt;= 0){
      alertText.innerText = "already potted reds";
      return;
    }

//otherwise:

      score ++;
      balls[0].quantity -= 1;
      redOn = false;
      alertText.innerText = "you potted red";
  }
</code></pre></div></div>

<p>Case 2:</p>

<p>When we try to pot a colour ball we need to check whether <code class="language-plaintext highlighter-rouge">tableCleared === true</code>. This will confirm what phase of the game we are in. If <code class="language-plaintext highlighter-rouge">tableCleared === true</code> we will move on to case 3, which handles the “clear the colours” phase. Otherwise we are still in the “red/colour” phase, so we now need to check the value of <code class="language-plaintext highlighter-rouge">redOn</code> to find out if we can shoot at a colour ball on our next go. If we pass this test, we can now update the state of the game:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function potColour(colour) {

//if all reds and final colour ball potted:

  if (tableCleared) {
    clearColours(colour);
    return;
  }

//if a colour ball has just been potted:

  if (redOn) {
    alertText.innerText = "choose a red ball";
    return;
  }

//otherwise:

  score += balls[lookup[colour]].points;
  redOn = true;
  alertText.innerText = "you potted " + colour;

//toggle tableCleared if final colour ball has just been potted:

  if (balls[0].quantity &lt; 1){
    tableCleared = true;
  }
}
</code></pre></div></div>

<p>Note that as well as updating <code class="language-plaintext highlighter-rouge">balls</code>, <code class="language-plaintext highlighter-rouge">score</code> and toggling <code class="language-plaintext highlighter-rouge">redOn</code> we now need to run a conditional against <code class="language-plaintext highlighter-rouge">tableCleared</code> every time we pot a colour during the “red/colour” phase. Remember, the reason why we check the game phase here and not during <code class="language-plaintext highlighter-rouge">potRed()</code> is because we only enter the “clear the colours” phase after the final red <em>and</em> the subsequent colour are potted. If <code class="language-plaintext highlighter-rouge">balls[0].quantity &lt; 1</code> and we’ve just potted a colour, we have satisfied these conditions and <code class="language-plaintext highlighter-rouge">tableCleared</code> can be toggled to <code class="language-plaintext highlighter-rouge">true</code>.</p>

<p>Note also that <code class="language-plaintext highlighter-rouge">potColour()</code> takes <code class="language-plaintext highlighter-rouge">colour</code> as an argument; we can pass a string like “yellow” or “green” into the function and use our lookup table to index this against the <code class="language-plaintext highlighter-rouge">balls</code> array.</p>

<p>Case 3:</p>

<p>This is our alternate case when a colour ball is selected during the second phase of the game. During this “clear the colours” phase we have new rules: we must pot all the colour balls in the correct points order, starting with yellow and finishing with black. Because the rules are now different, it felt simpler to create a new function to handle this, but case 3 could also be included as a branch within the potColour() function from case 2.</p>

<p>When we try to pot a colour ball we must first check that <code class="language-plaintext highlighter-rouge">balls[lookup[colour]].quantity &gt; 0</code> to confirm the ball has not already been potted. Next, we need to confirm that we are potting the ball at its correct order in the sequence. To do this, we iterate through the <code class="language-plaintext highlighter-rouge">balls</code> array up to the colour we are trying to pot, checking whether any of the colours have <code class="language-plaintext highlighter-rouge">quantity &gt; 0</code>. If we find a ball with <code class="language-plaintext highlighter-rouge">quantity &gt; 0</code> we stop immediately and return an alert stating that this ball must be potted first. If we pass that test, and we know that the ball we are trying to pot has <code class="language-plaintext highlighter-rouge">quantity &gt; 0</code>, we know that the ball is being potted in the correct order, so we can go ahead and update the game state.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function clearColours (colour) {

  //if colour ball has already been potted:

  if (balls[lookup[colour]].quantity &lt; 1){
    alertText.innerText = "already potted " + colour;
    return;
  }

  //else iterate through colour balls; if an earlier colour ball still needs to be potted:

  for (let i=1; i&lt;lookup[colour]; i++){
    if (balls[i].quantity &gt; 0){
      alertText.innerText = "you must pot " + balls[i].colour + " first";
      return;
    }
  }

  //otherwise:

  score += balls[lookup[colour]].points;
  balls[lookup[colour]].quantity --;
  alertText.innerText = "you potted " + balls[lookup[colour]].colour;

}
</code></pre></div></div>

<p>Great! We’ve now written code to handle the game state. The only thing left to do is to write some functions to tidy things up and update the DOM so our score bar displays correctly.</p>

<p><code class="language-plaintext highlighter-rouge">clearAlert()</code> allows us to clear our alert text; we’ll call this every time we call one of our potting functions.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function clearAlert () {
  alertText.innerText = "";
}
</code></pre></div></div>

<p>We’ve already mentioned the need for an <code class="language-plaintext highlighter-rouge">updateRemaining()</code> function to keep track of the number of points in the game. This will be called on initialisation before the game starts to set <code class="language-plaintext highlighter-rouge">maxPoints</code> and <code class="language-plaintext highlighter-rouge">remaining</code>. It will then be called every time we call a potting function and pass all the conditionals to legally pot the ball. To start with, we iterate through <code class="language-plaintext highlighter-rouge">balls</code>, using <code class="language-plaintext highlighter-rouge">total</code> to make a running count of <code class="language-plaintext highlighter-rouge">ball.points * ball.quantity</code>. This accounts for potting all the red balls, and potting all the colours during the “clear the colours” phase. However, we still need to add the colour balls available during the “red/colour” phase. For every red ball we can pot one colour ball, and since we are trying to calculate the maximum points remaining, we’ll assume this is always the black ball, which is worth the most points. To get the correct value we need to use <code class="language-plaintext highlighter-rouge">redOn</code> to check whether the ball we’ve just potted is a red. if <code class="language-plaintext highlighter-rouge">redOn === true</code> we can pot a black ball for every red ball, so  <code class="language-plaintext highlighter-rouge">total += balls[6].points * balls[0].quantity</code>. If <code class="language-plaintext highlighter-rouge">!redOn</code> we can pot a black ball for every red ball, but we also still need to pot the colour for the red we’ve just potted, so <code class="language-plaintext highlighter-rouge">total += balls[6].points * (balls[0].quantity + 1</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function updateRemaining () {

  let total = 0;

  for (const ball of balls){
    total += ball.points*ball.quantity
  }

  if (redOn){
    total += balls[lookup[black]].points * balls[lookup[red]].quantity;
  }
  else {
    total += balls[lookup[black]].points * (balls[lookup[red]].quantity + 1);
  }

  return total;

}
</code></pre></div></div>

<p>Finally, we need to write the function to update our DOM. The mark-up for our score bar elements looks like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;h2 id="score"&gt;score: 0&lt;/h2&gt;
&lt;div id="barContainer"&gt;
  &lt;div class = "bar" id = "maxBar"&gt;
    &lt;div class = "bar" id="pointsBar"&gt;&lt;/div&gt;
    &lt;div class = "bar" id="remainingBar"&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div id="pointer"&gt;
    &lt;div id = "untilWin"&gt;▲ win in 74 points&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">maxBar</code> element is the “outline” of the score bar. Following good responsive design practice, in the CSS, its <code class="language-plaintext highlighter-rouge">width</code> is set to 100% of its container, which means it will scale to the size of the viewing window. The <code class="language-plaintext highlighter-rouge">pointsBar</code> and <code class="language-plaintext highlighter-rouge">remainingBar</code> elements are the “points scored” and “points remaining” parts of the score bar. The full width of <code class="language-plaintext highlighter-rouge">maxBar</code> is equivalent to a perfect score of 147 points, so the widths of <code class="language-plaintext highlighter-rouge">scoreBar</code> and <code class="language-plaintext highlighter-rouge">remainingBar</code> should always be defined relative to this. With perfect play, <code class="language-plaintext highlighter-rouge">scoreBar</code> and <code class="language-plaintext highlighter-rouge">remainingBar</code> will fill the whole width of <code class="language-plaintext highlighter-rouge">maxBar</code>, but every time a non-optimal scoring choice is made the number of points in the game will go down, and we’ll see empty space appear in <code class="language-plaintext highlighter-rouge">maxBar</code>, showing the difference between the perfect score and the maximum possible score now achievable in our game.</p>

<p>We’ll control the size of these bars using the <code class="language-plaintext highlighter-rouge">width</code> property in the CSS as well; by creating these as child elements to <code class="language-plaintext highlighter-rouge">maxBar</code> and using percentage values for width (rather than px, rem, etc.) we can easily express the size of these bars in relation to the width of <code class="language-plaintext highlighter-rouge">maxBar</code>. If we adjust the width of <code class="language-plaintext highlighter-rouge">maxBar</code> by scaling the browser window, the scaling will be inherited by <code class="language-plaintext highlighter-rouge">pointsBar</code> and <code class="language-plaintext highlighter-rouge">remainingBar</code>, keeping everything locked in proportion.</p>

<p>The <code class="language-plaintext highlighter-rouge">pointer</code> element and its nested <code class="language-plaintext highlighter-rouge">untilWin</code> element show the winning line on the score bar. The position of <code class="language-plaintext highlighter-rouge">pointer</code> will be changed using the <code class="language-plaintext highlighter-rouge">left</code> CSS attribute.</p>

<p>We’ll use <code class="language-plaintext highlighter-rouge">document.getElementById()</code> to access the <code class="language-plaintext highlighter-rouge">pointsBar</code>, <code class="language-plaintext highlighter-rouge">remainingBar</code>, <code class="language-plaintext highlighter-rouge">pointer</code> and <code class="language-plaintext highlighter-rouge">untilWin</code> elements in the Javascript. Once we have access to these we can write the <code class="language-plaintext highlighter-rouge">updateBar()</code> function:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function updateBar() {

  // total points left in game
  let pointsAvailable = score + updateRemaining();

  let winningScore = (pointsAvailable%2 === 0) ?
  (pointsAvailable/2)+1 :
  Math.ceil(pointsAvailable/2);

  //update CSS with new values:

  pointsBar.style.width = `${score/maxPoints*100}%`;
  remainingBar.style.width = `${updateRemaining()/maxPoints*100}%`;
  pointerElement.style.marginLeft = `${winningScore/maxPoints*100}%`;

  untilWin.innerText = (winningScore - score &gt;= 0) ?
  `▲ win in ${winningScore - score} points` :
  "▲ win achieved";
}
</code></pre></div></div>

<p>Two new variables, <code class="language-plaintext highlighter-rouge">pointsAvailable</code> and <code class="language-plaintext highlighter-rouge">winningScore</code> allow us to update the position and text of our pointer element. Meanwhile, the <code class="language-plaintext highlighter-rouge">scoreBar</code> and <code class="language-plaintext highlighter-rouge">remainingBar</code> elements are upated using the globally available values for <code class="language-plaintext highlighter-rouge">score</code> and <code class="language-plaintext highlighter-rouge">updateRemaining()</code>. We also have access to anothe global variable, <code class="language-plaintext highlighter-rouge">maxPoints</code>, which represents our “perfect” 147 score. Since we need our <code class="language-plaintext highlighter-rouge">scoreBar</code> and <code class="language-plaintext highlighter-rouge">remainingBar</code> to be defined in relation to this perfect score we simply divide them by <code class="language-plaintext highlighter-rouge">maxPoints</code> and multiply by 100 to get a percentage value, which can now be passed back into the CSS. From here, the browser can calculate the correct pixel widths.</p>

<p>So that’s it! A functioning score calculator for snooker which provides an interesting, visualisation of the game state as the score changes. Having tested this I consider it viable, but there are plenty of updates worth making for the next version of the application.</p>

<p>When I work on this again I’ll focus on improving the user interface to make it simpler and more intuitive, and improving the score bar visualisation to be simpler to understand without a lot of explanation.</p>
:ET