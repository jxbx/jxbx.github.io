I"°)<p>There are lots of pattern generators online; <a href="https://doodad.dev/pattern-generator/">here‚Äôs an example</a> of a really nice one, which lets you export your artwork as svg graphics for use in your design work. <a href="https://haikei.app">Here‚Äôs something similar</a>; this tool generates simple graphic elements.</p>

<p>I‚Äôve always wanted to have a go at building a pattern generator which can create designs using typographic characters, and having recently used <a href="https://web.dev/variable-fonts/">variable fonts</a> in a project, I thought it would be really interesting to combine the two. With variable fonts, parameters like character weight can be continuously adjusted using CSS:</p>

<html>
  <style>
  @import url('https://fonts.googleapis.com/css2?family=Raleway:wght@100..900&display=swap');

    #container {
      font-family: 'Raleway';
      outline: 1px solid black;
    }

    #text1 {
      text-align: center;
      font-size: 50px;
      font-weight: 500;
      padding: 20px 0 0 0;
    }

    #weight1 {
      display: block;
      margin: auto;
      width: 50%;
    }

    #amount {
      display: block;
      margin: auto;
      width: 100px;
      padding: 0 0 20px 0;
    }

  </style>
<body>

  <div id="container">
    <p id="text1">Platypus</p>
    <input id="weight1" type="range" min="100" max="900" value="500" class="slider" oninput="changeWeight1()" />
    <p id="amount">Value: <span id="weightValue1">50</span></p>
  </div>

 </body>

 <script type="text/javascript">

   function changeWeight1 () {
     weightValue1.innerHTML = weight1.value;
     text1.style.fontWeight = weight1.value;
   };
 </script>

</html>

<p>Why not use characters from one of these variable fonts as elements in a pattern, and make these adjustable characteristics into parameters to help create different pattern designs?</p>

<p>How could this work? Well. let‚Äôs start with a simple character like ‚Äú‚Äî‚Äù, the classic em dash. In the image below, I‚Äôve started with a plain grid of em dashes, and created three new patterns just by applying some form of rotation to them. Initially, we‚Äôve rotated all the characters by the same value so they lie on a diagonal; then, we‚Äôve randomly rotated each character by either 0 or 90 degrees, to create an interesting maze-like figure; finally, we‚Äôve gone full random, rotating each character by its own arbitrary amount for an effect which looks a bit like ice cream sprinkles.</p>

<p><img class="blog-img" src="/blog/assets/dashpatterns.png" /></p>

<p>This is already starting to look quite cool. I really like the simplicity of using typographic characters as graphic elements, particularly simple symbols like +, -, O, and ~ . Even simple manipulations can create striking patterns, and we quickly forget we‚Äôre looking at type. Wouldn‚Äôt it be nice to have a character input which allows you to apply these sorts of transformations on any character? What would it look like if we used symbols like A, &amp; or $ in these designs? What other parameters can we build into our pattern generator to give us even more flexibility?</p>

<h2>Planning it out</h2>

<p>Let‚Äôs start planning out the objectives for this project:</p>

<ol>
  <li>
    <p>We need some method of generating patterns using typographic characters - this will require some kind of character input and some way to adjust parameters on these characters.</p>
  </li>
  <li>
    <p>Some of the following variables as parameters for the pattern generator:</p>
  </li>
</ol>

<p>Character spacing
Character orientation
Character weight (i.e. thickness)
Character colour
Character size
Background colour</p>

<ol>
  <li>
    <p>Some method of creating a repeating pattern from these designs</p>
  </li>
  <li>
    <p>Some method of downloading the designs in a useful graphics format</p>
  </li>
  <li>
    <p>Some method of generating css from the designs so they can be used as background textures in web pages</p>
  </li>
</ol>

<p>For now, I‚Äôm looking at the first two objectives. I think it‚Äôs worth hacking together a working program as a proof of concept just to see whether this approach can work. After this, I‚Äôll tackle point 3 and 4, which are concerned with creating a genuinely useful output from the program.</p>

<h2>First attempt</h2>

<p>You can have a look at my first pattern generator <a href="/projects/patternator2">here</a>. This version has absolutely not been tested for full compatibility across different devices and browsers, but it should run fine on a desktop device with Chrome. Pretty interesting right? Here are some patterns I made with this tool:</p>

<p><img class="blog-img" src="/blog/assets/05.jpg" /></p>

<h2>Building the grid</h2>

<p>So how are we going to start this? First of all, I‚Äôm going to define a space for my pattern swatch. I‚Äôll create the <code class="language-plaintext highlighter-rouge">gridContainer</code> div element and set its height and width to <code class="language-plaintext highlighter-rouge">600px</code>. I‚Äôll style it with the following CSS:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#gridContainer {
  display: grid;
  align-items: center;
  justify-content: center;
  grid-template: repeat(20, 50px) / repeat(20, 50px);
  position: relative;
  overflow: hidden;
}
</code></pre></div></div>

<p>This creates a 20x20 grid, which I can populate with characters to form my basic pattern element. I‚Äôve chosen a large grid because I want to allow for patterns with a lot of elements in them. I‚Äôm also going to build in functionality which allows the characters to be scaled, so I want to ensure that the grid is always big enough to fill the whole container even if the elements are close together. By setting  <code class="language-plaintext highlighter-rouge">overflow-hiddden</code> I‚Äôm ensuring that any elements that don‚Äôt fit into the container are kept out of sight.</p>

<p>My full grid is going to contain 400 cells (20x20), and I‚Äôll need to add an element to each of these. I don‚Äôt want to write that all out in html, so I‚Äôll use this script to help me:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (let i=0; i&lt;400; i++){
  const para = document.createElement("div");
  para.className = "gridItem";
  para.setAttribute("id", "cell"+i);

  const node = document.createTextNode("‚Äî");
  para.appendChild(node);

  const container = document.getElementById("gridContainer");
  container.appendChild(para);   
}
</code></pre></div></div>

<p>This loop will build each element, using <code class="language-plaintext highlighter-rouge">setAttribute()</code> to add the classname <code class="language-plaintext highlighter-rouge">gridItem</code> and the id <code class="language-plaintext highlighter-rouge">cell[i]</code> every time one of these elements is created.We can use <code class="language-plaintext highlighter-rouge">appendChild()</code> to add text to each of these elements, and again to add each element to the <code class="language-plaintext highlighter-rouge">gridContainer</code> .</p>

<h2>Adjusting the elements</h2>

<p>I set <code class="language-plaintext highlighter-rouge">overflow-hidden</code> on the container, with the idea that the 20x20 grid ought be big enough to fill it when the grid spacing and font size are set really low.</p>

<p>For the sake of experimentation (and because it‚Äôs fun), I built as many variables into the pattern generator as I could think of. It can produce some completely wild designs! Try the prototype here:</p>

<p>I‚Äôve created several sliders, which adjust css attributes to manipulate the text inside each cell using event listeners. The parameters in this prototype (with the associated css property in brackets) are font size (<code class="language-plaintext highlighter-rouge">font-size</code>), font weight (<code class="language-plaintext highlighter-rouge">font-weight</code>), drop shadow (<code class="language-plaintext highlighter-rouge">text-shadow</code>), rotation (<code class="language-plaintext highlighter-rouge">transform: rotate(...)</code>), stretching (<code class="language-plaintext highlighter-rouge">transform: stretch(...)</code>), spacing (<code class="language-plaintext highlighter-rouge">grid-template</code> - applied to the container rather than the cells), and a special parameter, jitter.</p>

<p>The jitter function is pretty fun, and adds an adjustable level of randomness to the positioning of the elements in the grid. The <code class="language-plaintext highlighter-rouge">randomMultiplier()</code> function adjusts the position of each grid item by passing a random number multiplied by the value on the input slider into the <code class="language-plaintext highlighter-rouge">margin</code> attribute in the stylesheet. The higher the slider value, the bigger the adjustment:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (const item of gridItems){
  const randomMultiplier = function() {
    let plusOrMinus = Math.random() &gt; 0.5 ? 1 : -1;
    return 0.5 * Math.random() * plusOrMinus;
  }
  item.style.margin = "0 0" + this.value*randomMultiplier() + "px " + this.value*randomMultiplier() + "px";
}
</code></pre></div></div>

<p>I also built in the option of adjusting the alignment of the individual elements to one of four settings: regular (every element is rotated 0 degrees) alternating (every second element is rotated 90 degrees); random (every element has a random amount of rotation applied); right angles (elements are rotated either 90 degrees or 0 degrees at random).</p>

<p>Finally, I added a blend mode selector, which uses the <code class="language-plaintext highlighter-rouge">mix-blend-mode</code> css attribute to apply a blend style from a predefined list:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let blends = ["normal", "multiply", "hard-light", "soft-light", "difference", "screen", "overlay", "color"];
</code></pre></div></div>

<p>That‚Äôs a lot of options! This makes the pattern generator seriously enjoyable to play with, but it‚Äôs also useful for testing which parameters help to make genuinely interesting patterns and which are too gimicky to be of serious use.</p>

<p>I‚Äôve also used this proof of concept as a testing ground for a couple of packages - a custom colour picker with a built in alpha channel, and a ‚Äúscreenshot‚Äù tool which saves the pattern swatch as a png image.</p>
:ET