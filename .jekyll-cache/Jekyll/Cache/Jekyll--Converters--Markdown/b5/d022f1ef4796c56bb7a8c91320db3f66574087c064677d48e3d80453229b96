I"í!<p>Here‚Äôs a very simple game which plays a little bit like Snake ‚Ä¶ without the snake. You play as the white dot, chasing a static enemy around the play area, and every time you catch the enemy it respawns in a random location. This is still trivial at the moment, since there‚Äôs no additional gameplay element to add increasing interest or difficulty. For now the limiting factor is simply your own endurance or boredom!</p>

<iframe src="https://www.justinbailey.net/projects/simplegame.html" height="670"></iframe>

<p>I‚Äôve spent a bit of time learning how to draw elements using the Javascript canvas, but I decided to try a different approach here: the game is drawn using the DOM, and the play area, player and enemy are all simple &lt;div&gt; elements. I like the fact that there‚Äôs no need to write an explicit rendering function in the Javascript with this approach, although there are limitations to drawing shapes in CSS.</p>

<p>Player, enemy, and play area</p>

<p>I started off by creating an HTML file and adding &lt;div&gt; elements for the player, play area and score counter. I then added some simple CSS styling and began writing the program.</p>

<p>The initial &lt;div&gt; elements are linked into the Javascript from the HTML, but the enemy element is actually defined within the program body:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const enemyElement = document.createElement("div");
enemyElement.id = "enemy";
document.getElementById("playArea").appendChild(enemyElement);
</code></pre></div></div>

<p>While working on this I realised that allowing the program to generate new elements is much more dynamic than hardcoding them directly into the HTML, although for a game this simple either method works.</p>

<p>Movement</p>

<p>The player is moved using <code class="language-plaintext highlighter-rouge">playerElement.style.top</code> and <code class="language-plaintext highlighter-rouge">playerElement.style.left</code> to access the player‚Äôs <code class="language-plaintext highlighter-rouge">top</code> and <code class="language-plaintext highlighter-rouge">left</code> properties in the CSS. By manipulating these values you can ‚Äúpush‚Äù the player around inside the play area.</p>

<p>A couple of variables define the starting position of the playerElement in terms of x and y coordinates with respect to the play area. The <code class="language-plaintext highlighter-rouge">MoveUp()</code>, <code class="language-plaintext highlighter-rouge">MoveDown()</code>, <code class="language-plaintext highlighter-rouge">MoveLeft()</code> and <code class="language-plaintext highlighter-rouge">MoveRight()</code> functions access these coordinates and increment by 5px in the required direction when called. A condition is added using <code class="language-plaintext highlighter-rouge">Math.min</code> or <code class="language-plaintext highlighter-rouge">Math.max</code> to ensure <code class="language-plaintext highlighter-rouge">playerElement</code> can never leave the play area.</p>

<p>Using an expression like <code class="language-plaintext highlighter-rouge">yPlayer &lt;= {width of play area}</code> to add this condition is okay too, but it‚Äôs a bit messy since it needs to be carefully defined to stop the playerElement from partially leaving the play area in limit cases.</p>

<p><code class="language-plaintext highlighter-rouge">Math.min</code> is a great option here as a simple method to enforce limits.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let yPlayer = 550;
let xPlayer = 190;

function moveUp() {
    yPlayer = Math.max(0, yPlayer - 5);
    playerElement.style.top = `${yPlayer}px`;
    }

function moveDown() {
    yPlayer = Math.min(580, yPlayer + 5);
    playerElement.style.top = `${yPlayer}px`;
    }

function moveLeft() {
    xPlayer = Math.max(0, xPlayer - 5);
    playerElement.style.left = `${xPlayer}px`;
    }

function moveRight() {
    xPlayer = Math.min(380, xPlayer + 5);
    playerElement.style.left = `${xPlayer}px`;
    }
</code></pre></div></div>

<p>Collisions and respawning and scoring</p>

<p>The static enemy has its own position variables, which are generated using the Math.random method. The respawnEmemy() function allows us to update these variables with new random variables on call.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let yEnemy = Math.random() * 580;
let xEnemy = Math.random() * 380;

function respawnEnemy(){
yEnemy = Math.random() * 580;
xEnemy = Math.random() * 380;
enemyElement.style.top = `${yEnemy}px`;
enemyElement.style.left = `${xEnemy}px`;  
}
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">updateScore()</code> function accesses a scoreTracker variable (initially set to 0), increment it, and returns the new value into an HTML element called ‚Äúscore‚Äù.</p>

<p>The <code class="language-plaintext highlighter-rouge">detectCollision()</code> accesses the values for <code class="language-plaintext highlighter-rouge">xPlayer</code>, <code class="language-plaintext highlighter-rouge">yPlayer</code>, <code class="language-plaintext highlighter-rouge">xEnemy</code> and <code class="language-plaintext highlighter-rouge">yEnemy</code> and uses a couple of comparative expressions to check whether these values overlap. A successful collision triggers the <code class="language-plaintext highlighter-rouge">respawnEnemy()</code> and <code class="language-plaintext highlighter-rouge">updateScore()</code> functions.</p>

<p>Making it work</p>

<p>Finally, an <code class="language-plaintext highlighter-rouge">animate()</code> function wraps round these other functions and ends with a <code class="language-plaintext highlighter-rouge">requestAnimationFrame()</code> call to create a loop and ensure the play area is repeatedly refreshed. As mentioned, there‚Äôs no need for an explicit render function because the DOM will handle this.</p>

<p>Solving the movement problem</p>

<p>I added a couple of event listeners to detect keydown events and trigger the move functions. Project completed? Absolutely not. The game works okay in this form, but like many other beginner coders I‚Äôve now learned that the program‚Äôs default response to keyboard inputs is seriously unsuited to fluid gameplay!</p>

<p>The action we want is for the program to accept multiple inputs and interpolate these smoothly to give the impression of free and continuous movement in all directions. Inputting ‚Äúup‚Äù and ‚Äúleft‚Äù at the same time should allow us to move diagonally, and switching from input from ‚Äúleft‚Äù to ‚Äúright‚Äù should let us change direction instantly. Instead, the program‚Äôs default behaviour when it receives multiple inputs is to ‚Äúforget‚Äù the initial input and stop until a new input is received, resulting in jerky movement.</p>

<p>To override this behaviour we need to detach our move functions from direct control by the keyboard inputs and find some system for logging inputs so they aren‚Äôt ‚Äúforgotten‚Äù when a new input is detected.</p>

<p>The controller object below records boolean values against our arrow inputs. By default it records false, but it can be altered by two functions: updateKeydown() flips the value to true as soon as a keydown event is detected on the relevant key. The value stays true until the equivalent keyup event is detected on the same key by the updateKeyup() function, which flips it to false again. Any or all of the states in this array can read true or false separately or simultaneously.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const controller = {
    ArrowLeft: { pressed: false},
    ArrowUp: { pressed: false},
    ArrowRight: { pressed: false},
    ArrowDown: { pressed: false}
  };

  function updateKeydown(event) {
      if (controller[event.key]) {
      controller[event.key].pressed = true;
      event.preventDefault();
    }
  }

  function updateKeyup(event) {
    if (controller[event.key]) {
     controller[event.key].pressed = false;
     event.preventDefault();
    }
  }
</code></pre></div></div>

<p>This is great: instead of using key inputs to directly move the playerElement we are using them to update the controller object. The controller records all of our input states continuously,  and passes these values into our move functions, which now interpolate smoothly when triggered.</p>
:ET